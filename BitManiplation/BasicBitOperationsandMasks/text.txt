////////////////// Main Formulas /////////////
(a) Get i-th bit
(n >> i) & 1


Example: n = 13 (1101), i = 2 → 1

(b) Set i-th bit (force to 1)
n | (1 << i)


Example: n=13 (1101), set bit 1 → 1111 (15)

(c) Clear i-th bit (force to 0)
n & ~(1 << i)


Example: n=13 (1101), clear bit 2 → 1001 (9)

(d) Toggle i-th bit (flip 0 ↔ 1)
n ^ (1 << i)


Example: n=13 (1101), toggle bit 0 → 1100 (12


///Basic Bit Operations and Masks
2.1 Core Bitwise Operators
Operator	Symbol	Meaning (bit-level)
AND	&	1 if both bits are 1
OR	`	`
XOR	^	1 if bits differ
NOT	~	Inverts all bits
Shift L	<<	Shift left (×2ᵏ)
Shift R	>>	Shift right (÷2ᵏ)


2.2 Masks

A mask = binary number used with AND/OR/XOR to manipulate specific bits.

Bitwise masks are fundamental tools in computer programming, allowing you to manipulate specific bits within a binary number without affecting the others. They work by creating a temporary binary number (the mask) that has a '1' only at the position you want to change, and then using a bitwise operator (AND, OR, XOR) with the original number.

Here is a step-by-step explanation for each operation, using the concept of a mask M=(1≪i).

1. Creating the Mask (M)
All these operations start by creating a mask M=(1≪i), which is a '1' shifted to the i-th position (counting from the right, starting at i=0).

Example (i=2):1=0001
Shift left by 2:1≪2=0100(Mask M)
(a) Get i-th Bit (Check)
(n≫i) & 1
This operation determines if the i-th bit of n is a 0 or a 1.

Shift Right (n≫i): The number n is shifted right by i positions. This moves the i-th bit all the way to the 2 
0
  (rightmost) position.

AND with 1 (…&1): A bitwise AND with '1' is applied. Since 1=…0001, this operation clears (sets to 0) every bit except the rightmost bit.

If the i-th bit was 1, the result will be 1.

If the i-th bit was 0, the result will be 0.

Example: n=13 (1101), i=2
1101≫2⟶0011
0011 & 0001⟶0001 (Decimal 1)
Result: The 2nd bit is 1.

Export to Sheets
(b) Set i-th Bit (Force to 1)
n ∣ (1≪i)
This operation guarantees that the i-th bit in n will be a 1.

Create Mask (M): A mask M is created with a '1' only at the i-th position.

Bitwise OR (∣): The OR operation guarantees a '1' in the result if either operand has a '1' at that position.

If n's i-th bit is already 1, ORing with M's '1' keeps it 1.

If n's i-th bit is 0, ORing with M's '1' forces it to 1.

All other bits are ORed with M's '0's and remain unchanged.

Example: n=13 (1101), set i=1
n=1101
Mask M=1≪1⟶0010
$1101 \

Export to Sheets
(c) Clear i-th Bit (Force to 0)
n & ∼(1≪i)
This operation guarantees that the i-th bit in n will be a 0.

Create Mask (M): A mask M is created with a '1' only at the i-th position.

Invert Mask (∼M): The mask is inverted, creating a new mask that is all '1's, except for a '0' at the i-th position.

Bitwise AND (&): The AND operation guarantees a '0' in the result if either operand has a '0' at that position.

At the i-th position, the inverted mask has a 0, which forces the result to 0, regardless of n's original bit.

All other bits are ANDed with the inverted mask's '1's and remain unchanged.

Example: n=13 (1101), clear i=2
n=1101
Mask M=1≪2⟶0100
Inverted Mask ∼M⟶1011
1101 & 1011⟶1001 (Decimal 9)

Export to Sheets
(d) Toggle i-th Bit (Flip 0 ↔ 1)
n ∧ (1≪i)
This operation flips the value of the i-th bit (0 becomes 1, and 1 becomes 0).

Create Mask (M): A mask M is created with a '1' only at the i-th position.

Bitwise XOR (∧): The XOR (Exclusive OR) operation returns a '1' if the two bits are different, and a '0' if they are the same.

At the i-th position, XORing with the mask's 1 flips the bit (0 becomes 1, 1 becomes 0).

All other bits are XORed with the mask's '0's and remain unchanged.

Example: n=13 (1101), toggle i=0
n=1101
Mask M=1≪0⟶0001
1101 ∧ 0001⟶1100 (Decimal 12)


practice - 1

What is the binary result of 29 & 23?

steps
1. find both binary numbers
2. addition that 
3.we get result
4.convert result to decimal adding 2's powers.

& if both bits are 1 it is 1


The binary result of 29&23 is 21.

This is found by performing the Bitwise AND operation on the binary representations of the two numbers.

Step-by-Step Calculation
1. Convert to Binary
First, convert the decimal numbers 29 and 23 into their binary representations. We can use 5 bits, as 2 
4
 =16 and 2 
5
 =32.

29

(1×16)+(1×8)+(1×4)+(0×2)+(1×1)=16+8+4+1=29
29=11101 
2
​
 
23

(1×16)+(0×8)+(1×4)+(1×2)+(1×1)=16+4+2+1=23
23=10111 
2
​
 
2. Perform the Bitwise AND (&)
The Bitwise AND operator (&) compares the corresponding bits of the two numbers. It only returns a 1 if both bits are 1. Otherwise, it returns 0.

29
&23
Result
​
  
1
1
1
​
  
1
0
0
​
  
1
1
1
​
  
0
1
0
​
  
1
1
1
​
 
​
 
The binary result is 10101 
2
​
 .

3. Convert Result to Decimal
Finally, convert the binary result 10101 
2
​
  back to decimal:

(1×16)+(0×8)+(1×4)+(0×2)+(1×1)=16+4+1=21





2)For n = 21 (10101), set bit 1 and show the new decimal.

The operation uses the formula: 

n ∣ (1≪i) In your case, n=21 and i=1 (the 1 st  bit).
Bitwise OR (∣) 


